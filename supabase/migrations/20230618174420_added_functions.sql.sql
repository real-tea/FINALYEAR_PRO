CREATE TABLE "public"."tbl_document_versions"(
	"document_id" text NOT NULL,
	"document_version" bigint NOT NULL DEFAULT '1' ::bigint,
	"created_at" timestamp with time zone DEFAULT now(),
	"is_enabled" boolean NOT NULL DEFAULT TRUE,
	"page_count" bigint
);

ALTER TABLE "public"."tbl_document_versions" ENABLE ROW LEVEL SECURITY;

CREATE TABLE "public"."tbl_view_logs"(
	"view_log_seq" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	"view_id" text,
	"page_num" bigint NOT NULL DEFAULT '0' ::bigint,
	"view_start_at" timestamp with time zone,
	"view_end_at" timestamp with time zone
);

ALTER TABLE "public"."tbl_view_logs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."tbl_documents"
	DROP COLUMN "name";

ALTER TABLE "public"."tbl_documents"
	ADD COLUMN "document_name" text NOT NULL;

ALTER TABLE "public"."tbl_links"
	DROP COLUMN "name";

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "domain_restricted" boolean NOT NULL DEFAULT FALSE;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "download_allowed" boolean NOT NULL DEFAULT FALSE;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "email_required" boolean NOT NULL DEFAULT FALSE;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "link_name" text NOT NULL;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "link_password" text;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "password_required" boolean NOT NULL DEFAULT FALSE;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "restricted_domains" text;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "verify_email" boolean NOT NULL DEFAULT FALSE;

ALTER TABLE "public"."tbl_links"
	ADD COLUMN "watermarked" boolean NOT NULL DEFAULT FALSE;

ALTER TABLE "public"."tbl_links"
	ALTER COLUMN "link_id" DROP NOT NULL;

ALTER TABLE "public"."tbl_views"
	ADD COLUMN "document_version" bigint;

CREATE UNIQUE INDEX tbl_document_versions_pkey ON public.tbl_document_versions USING btree(document_version, document_id);

CREATE UNIQUE INDEX tbl_view_logs_pkey ON public.tbl_view_logs USING btree(view_log_seq);

ALTER TABLE "public"."tbl_document_versions"
	ADD CONSTRAINT "tbl_document_versions_pkey" PRIMARY KEY USING INDEX "tbl_document_versions_pkey";

ALTER TABLE "public"."tbl_view_logs"
	ADD CONSTRAINT "tbl_view_logs_pkey" PRIMARY KEY USING INDEX "tbl_view_logs_pkey";

ALTER TABLE "public"."tbl_document_versions"
	ADD CONSTRAINT "tbl_document_versions_document_id_fkey" FOREIGN KEY (document_id) REFERENCES tbl_documents(document_id) ON DELETE CASCADE NOT valid;

ALTER TABLE "public"."tbl_document_versions" validate CONSTRAINT "tbl_document_versions_document_id_fkey";

ALTER TABLE "public"."tbl_view_logs"
	ADD CONSTRAINT "tbl_view_logs_view_id_fkey" FOREIGN KEY (view_id) REFERENCES tbl_views(view_id) ON DELETE CASCADE NOT valid;

ALTER TABLE "public"."tbl_view_logs" validate CONSTRAINT "tbl_view_logs_view_id_fkey";

ALTER TABLE "public"."tbl_views"
	ADD CONSTRAINT "tbl_views_link_id_fkey" FOREIGN KEY (link_id) REFERENCES tbl_links(link_id) ON DELETE SET NULL NOT valid;

ALTER TABLE "public"."tbl_views" validate CONSTRAINT "tbl_views_link_id_fkey";

SET check_function_bodies = OFF;

CREATE OR REPLACE FUNCTION public.authorize_viewer(link_id_input text, email_input text DEFAULT NULL::text, password_input text DEFAULT NULL::text)
	RETURNS json
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $function$
DECLARE
	return_data json;
	view_row tbl_views;
	jwt_metadata json;
	time_input timestamptz;
	new_token text;
BEGIN
	--
	--
	IF (link_id_input IS NULL) THEN
		RAISE EXCEPTION 'Invalid link_id';
	END IF;
	--
	--
	INSERT INTO tbl_views(
		link_id,
		viewer,
		document_version)
	SELECT
		link_id,
		email_input,
		document_version
	FROM
		tbl_links
	LEFT JOIN tbl_document_versions ON tbl_links.document_id = tbl_document_versions.document_id
WHERE
	tbl_links.link_id = link_id_input
		AND tbl_document_versions.is_enabled = TRUE
	RETURNING
		* INTO view_row;
	--
	--
	IF (view_row IS NULL) THEN
		RAISE EXCEPTION 'Invalid link_id';
	END IF;
	--
	--
	time_input = now();
	--
	--
	jwt_metadata := json_build_object('aud', 'authenticated', 'iat', extract(epoch FROM time_input), 'exp', extract(epoch FROM time_input) + 60 * 60, 'role', 'authenticated', 'link_id', view_row.link_id, 'view_id', view_row.view_id, 'viewer', view_row.viewer, 'document_version', view_row.document_version);
	--
	--
	-- SELECT
	-- 	sign(jwt_metadata, current_setting('app.settings.jwt_secret')) INTO new_token;
	--
	--
	SELECT
		sign(jwt_metadata, 'super-secret-jwt-token-with-at-least-32-characters-long') INTO new_token;
	--
	--
	return_data = json_build_object('view_token', new_token, 'view', view_row);
	RETURN return_data;
END
$function$;

CREATE OR REPLACE FUNCTION public.func_before_insert_tbl_links()
	RETURNS TRIGGER
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $function$
BEGIN
	NEW.link_id := gen_links_id();
	RETURN NEW;
END
$function$;

CREATE OR REPLACE FUNCTION public.func_before_insert_tbl_views()
	RETURNS TRIGGER
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $function$
BEGIN
	NEW.view_id := gen_view_id(NEW.link_id);
	RETURN NEW;
END
$function$;

CREATE OR REPLACE FUNCTION public.gen_view_id(link_id_input text)
	RETURNS text
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $function$
DECLARE
	idBuilder text := '';
	counter int := 0;
	bytes bytea;
	alphabetIndex int;
	alphabetArray text[];
	alphabetLength int;
	mask int;
	step int;
	size int := 6;
	alphabet text := 'abcdefghijklmnopqrstuvwxyz';
BEGIN
	alphabetArray := regexp_split_to_array(alphabet, '');
	alphabetLength := array_length(alphabetArray, 1);
	mask :=(2 << cast(floor(log(alphabetLength - 1) / log(2)) AS int)) - 1;
	step := cast(ceil(1.6 * mask * size / alphabetLength) AS int);
	while TRUE LOOP
		bytes := gen_random_bytes(step);
		while counter < step LOOP
			alphabetIndex :=(get_byte(bytes, counter) & mask) + 1;
			IF alphabetIndex <= alphabetLength THEN
				idBuilder := idBuilder || alphabetArray[alphabetIndex];
				IF length(idBuilder) = size THEN
					RETURN link_id_input || '-' || idBuilder;
				END IF;
			END IF;
			counter := counter + 1;
		END LOOP;
		counter := 0;
	END LOOP;
END
$function$;

CREATE OR REPLACE FUNCTION public.get_document_id(document_id_input text DEFAULT NULL::text)
	RETURNS json
	LANGUAGE plpgsql
	AS $function$
DECLARE
	return_data json;
BEGIN
	WITH views AS (
		SELECT
			tbl_views.view_seq,
			tbl_views.link_id,
			tbl_views.view_id,
			tbl_views.viewed_at,
			tbl_views.viewer,
			tbl_views.document_version,
			coalesce(max(tbl_view_logs.view_end_at) - min(tbl_view_logs.view_start_at), interval '0') AS duration,
			round(count(page_num) / tbl_document_versions.page_count::numeric * 100, 0)::numeric AS completion
		FROM
			tbl_views
		LEFT JOIN tbl_view_logs ON tbl_views.view_id = tbl_view_logs.view_id
		LEFT JOIN tbl_links ON tbl_links.link_id = tbl_views.link_id
		LEFT JOIN tbl_document_versions ON tbl_document_versions.document_id = tbl_links.document_id
	GROUP BY
		tbl_views.view_seq,
		tbl_views.link_id,
		tbl_views.view_id,
		tbl_views.viewed_at,
		tbl_views.viewer,
		tbl_views.document_version,
		tbl_document_versions.page_count
	ORDER BY
		tbl_views.view_seq DESC
),
links AS (
	SELECT
		tbl_links.link_seq,
		tbl_links.link_id,
		tbl_links.link_name,
		tbl_links.created_at,
		tbl_links.is_active,
		tbl_links.document_id,
		tbl_links.created_by,
		tbl_links.email_required,
		tbl_links.password_required,
		tbl_links.verify_email,
		tbl_links.domain_restricted,
		tbl_links.download_allowed,
		tbl_links.watermarked,
		tbl_links.restricted_domains,
		tbl_links.link_password,
		count(DISTINCT views.view_id) AS view_count,
		CASE WHEN count(DISTINCT views.view_id) = 0 THEN
			ARRAY[]::json[]
		ELSE
			array_agg(row_to_json(views.*))
		END AS views
	FROM
		tbl_links
		LEFT JOIN views ON views.link_id = tbl_links.link_id
	GROUP BY
		tbl_links.link_seq,
		tbl_links.link_id,
		tbl_links.link_name,
		tbl_links.created_at,
		tbl_links.is_active,
		tbl_links.document_id,
		tbl_links.created_by,
		tbl_links.email_required,
		tbl_links.password_required,
		tbl_links.verify_email,
		tbl_links.domain_restricted,
		tbl_links.download_allowed,
		tbl_links.watermarked,
		tbl_links.restricted_domains,
		tbl_links.link_password
	ORDER BY
		tbl_links.link_seq DESC
)
SELECT
	json_agg(row_to_json(t))
FROM (
	SELECT
		tbl_documents.document_seq,
		tbl_documents.document_id,
		tbl_documents.created_at,
		tbl_documents.document_name,
		tbl_documents.source_path,
		tbl_documents.source_type,
		tbl_documents.created_by,
		tbl_documents.org_id,
		tbl_documents.is_enabled,
		tbl_documents.image,
		count(links.link_id) AS total_links_count,
		sum(links.view_count) AS total_view_Count,
		CASE WHEN count(DISTINCT links.link_id) = 0 THEN
			ARRAY[]::json[]
		ELSE
			array_agg(row_to_json(links.*))
		END AS links
	FROM
		tbl_documents
	LEFT JOIN links ON tbl_documents.document_id = links.document_id
WHERE
	CASE WHEN document_id_input IS NULL THEN
		tbl_documents.org_id = list_org_from_user()
	ELSE
		tbl_documents.document_id = document_id_input
	END
GROUP BY
	tbl_documents.document_seq,
	tbl_documents.document_id,
	tbl_documents.created_at,
	tbl_documents.document_name,
	tbl_documents.source_path,
	tbl_documents.source_type,
	tbl_documents.created_by,
	tbl_documents.org_id,
	tbl_documents.is_enabled,
	tbl_documents.image
ORDER BY
	tbl_documents.document_seq DESC) t INTO return_data;
	RETURN return_data;
END;
$function$;

CREATE POLICY "ALL if user belongs to org" ON "public"."tbl_document_versions" AS permissive
	FOR ALL TO authenticated
		USING ((document_id IN (
			SELECT
				tbl_documents.document_id
			FROM
				tbl_documents
			WHERE (tbl_documents.org_id = list_org_from_user()))))
		WITH CHECK ((document_id IN (
			SELECT
				tbl_documents.document_id
			FROM
				tbl_documents
			WHERE (tbl_documents.org_id = list_org_from_user()))));

CREATE POLICY "ALL if document belongs to user org" ON "public"."tbl_links" AS permissive
	FOR ALL TO authenticated
		USING ((document_id IN (
			SELECT
				tbl_documents.document_id
			FROM
				tbl_documents
			WHERE (tbl_documents.org_id = list_org_from_user()))))
		WITH CHECK ((document_id IN (
			SELECT
				tbl_documents.document_id
			FROM
				tbl_documents
			WHERE (tbl_documents.org_id = list_org_from_user()))));

CREATE POLICY "SELECT if viewer" ON "public"."tbl_links" AS permissive
	FOR SELECT TO authenticated
		USING ((link_id =(auth.jwt() ->> 'link_id'::text)));

CREATE POLICY "ALL if user belongs to org" ON "public"."tbl_view_logs" AS permissive
	FOR ALL TO authenticated
		USING ((view_id IN (
			SELECT
				tbl_views.view_id
			FROM ((tbl_views
		LEFT JOIN tbl_links ON (tbl_links.link_id = tbl_views.link_id))
		LEFT JOIN tbl_documents ON (tbl_links.document_id = tbl_documents.document_id))
	WHERE (tbl_documents.org_id = list_org_from_user()))))
WITH CHECK ((view_id IN (
	SELECT
		tbl_views.view_id
	FROM ((tbl_views
	LEFT JOIN tbl_links ON (tbl_links.link_id = tbl_views.link_id))
	LEFT JOIN tbl_documents ON (tbl_links.document_id = tbl_documents.document_id))
WHERE (tbl_documents.org_id = list_org_from_user()))));

CREATE POLICY "ALL if user belongs to org" ON "public"."tbl_views" AS permissive
	FOR ALL TO authenticated
		USING ((link_id IN (
			SELECT
				tbl_links.link_id
			FROM (tbl_links
		LEFT JOIN tbl_documents ON (tbl_links.document_id = tbl_documents.document_id))
	WHERE (tbl_documents.org_id = list_org_from_user()))))
WITH CHECK ((link_id IN (
	SELECT
		tbl_links.link_id
	FROM (tbl_links
	LEFT JOIN tbl_documents ON (tbl_links.document_id = tbl_documents.document_id))
WHERE (tbl_documents.org_id = list_org_from_user()))));

CREATE POLICY "SELECT if viewer" ON "public"."tbl_views" AS permissive
	FOR SELECT TO authenticated
		USING ((view_id =(auth.jwt() ->> 'view_id'::text)));

CREATE TRIGGER trigger_before_insert_tbl_links
	BEFORE INSERT ON public.tbl_links
	FOR EACH ROW
	EXECUTE FUNCTION func_before_insert_tbl_links();

CREATE TRIGGER trigger_before_insert_tbl_views
	BEFORE INSERT ON public.tbl_views
	FOR EACH ROW
	EXECUTE FUNCTION func_before_insert_tbl_views();

